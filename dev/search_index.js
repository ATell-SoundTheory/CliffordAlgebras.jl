var documenterSearchIndex = {"docs":
[{"location":"recipes/#Recipes:-CGA-and-PGA","page":"Recipes","title":"Recipes: CGA & PGA","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"This page collects small, practical recipes for common tasks in projective and conformal geometric algebra.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"All snippets are doctest-able and ASCII-friendly where possible.","category":"page"},{"location":"recipes/#Contract","page":"Recipes","title":"Contract","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Input: an algebra and a few multivectors\nOutput: a result multivector of interest\nErrors: invalid signatures or division by zero where noted\nSuccess: example evaluates and type-stable on recent Julia","category":"page"},{"location":"recipes/#PGA:-reflect-a-vector-in-a-plane-(householder-like)","page":"Recipes","title":"PGA: reflect a vector in a plane (householder-like)","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3 = basevector(pga,1), basevector(pga,2), basevector(pga,3);\n\njulia> n = e2;  # plane normal (unit for simplicity)\n\njulia> v = e1 + 2e2 + 3e3;\n\njulia> R = exp(π * (n ∧ e3) / 2);  # 180° around axis orthogonal to plane -> reflection\n\njulia> v_ref = R ≀ v; v_ref isa MultiVector; true\ntrue","category":"page"},{"location":"recipes/#PGA:-intersection-of-two-planes-line","page":"Recipes","title":"PGA: intersection of two planes -> line","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3, e0 = basevector(pga,1), basevector(pga,2), basevector(pga,3), basevector(pga,:e0);\n\njulia> plane_xy = e3;  # z=0 plane\n\njulia> plane_xz = e2;  # y=0 plane\n\njulia> line = plane_xy ∧ plane_xz;\n\njulia> isgrade(line, 2)\ntrue","category":"page"},{"location":"recipes/#PGA:-reflect-a-vector-in-a-plane","page":"Recipes","title":"PGA: reflect a vector in a plane","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Reflect across the plane z=0 (normal e3). The z component flips.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3 = basevector(pga,1), basevector(pga,2), basevector(pga,3);\n\njulia> plane = e3;  # z=0\n\njulia> v = e1 + e3;\n\njulia> v_ref = plane ≀ v; true\ntrue","category":"page"},{"location":"recipes/#PGA:-line-plane-meet-point","page":"Recipes","title":"PGA: line-plane meet -> point","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"The meet (∨) of a line and a plane yields a point (grade-3 in PGA3D).","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3 = basevector(pga,1), basevector(pga,2), basevector(pga,3);\n\njulia> plane_xy = e3;      # z=0\n\njulia> plane_xz = e2;      # y=0\n\njulia> line = plane_xy ∧ plane_xz;  # x-axis line\n\njulia> plane_yz = e1;      # x=0\n\njulia> pt = line ∨ plane_yz;\n\njulia> isgrade(pt, 3)\ntrue","category":"page"},{"location":"recipes/#PGA:-rigid-body-motor-(rotation-translation)","page":"Recipes","title":"PGA: rigid-body motor (rotation + translation)","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Compose a small rotation about z with a small translation along x, then apply to a vector.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3, e0 = basevector(pga,1), basevector(pga,2), basevector(pga,3), basevector(pga,:e0);\n\njulia> B = (π/12) * (e1 ∧ e2);      # rotate about z\n\njulia> T = 0.05 * (e0 ∧ e1);        # translate along x (translator-like)\n\njulia> M = exp(B + T);\n\njulia> v = e1 + 2e2;  # a direction-grade representative\n\njulia> v2 = M ≀ v; v2 isa MultiVector; true\ntrue","category":"page"},{"location":"recipes/#Cl3:-compose-two-rotations-via-rotors","page":"Recipes","title":"Cl3: compose two rotations via rotors","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> cl3 = CliffordAlgebra(3);\n\njulia> e1, e2, e3 = cl3.e1, cl3.e2, cl3.e3;\n\njulia> B1 = (π/6) * (e1 ∧ e2);\n\njulia> B2 = (π/7) * (e2 ∧ e3);\n\njulia> R1, R2 = exp(B1), exp(B2);\n\njulia> v = e1 + 2e2 + 3e3;\n\njulia> v_seq = R2 ≀ (R1 ≀ v);\n\njulia> v_comb = (R2 * R1) ≀ v; true\ntrue","category":"page"},{"location":"recipes/#STA:-Lorentz-boost-via-bivector-exponential","page":"Recipes","title":"STA: Lorentz boost via bivector exponential","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Boost along x with rapidity 0.1 (using generator t∧x). Minkowski norm is preserved.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> sta = CliffordAlgebra(:Spacetime);\n\njulia> t, x = basevector(sta,:t), basevector(sta,:x);\n\njulia> B = 0.1 * (t ∧ x);\n\njulia> R = exp(B);\n\njulia> v = t + 0.5x;  # timelike vector with small spatial part\n\njulia> vb = R ≀ v;    # boosted\n\njulia> s(a) = scalar(a * ~a);\n\njulia> isgrade(vb, 1) && s(vb) ≈ s(v)\ntrue","category":"page"},{"location":"recipes/#CGA:-rotate-a-Euclidean-vector-by-a-rotor","page":"Recipes","title":"CGA: rotate a Euclidean vector by a rotor","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> cga = CliffordAlgebra(:CGA3D);\n\njulia> e1, e2, e3 = basevector(cga,1), basevector(cga,2), basevector(cga,3);\n\njulia> B = (π/6) * (e1 ∧ e2);\n\njulia> R = exp(B);\n\njulia> v = e1 + e2;\n\njulia> v_rot = R ≀ v; v_rot isa MultiVector; true\ntrue","category":"page"},{"location":"recipes/#CGA:-translate-a-point-using-a-motor-(CGA-screw-motion)","page":"Recipes","title":"CGA: translate a point using a motor (CGA screw motion)","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Note: For brevity, we model a simple translation by building a null bivector.","category":"page"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> cga = CliffordAlgebra(:CGA3D);\n\njulia> e1, e2, e3 = basevector(cga,1), basevector(cga,2), basevector(cga,3);\n\njulia> eplus, eminus = basevector(cga,:e₊), basevector(cga,:e₋);\n\njulia> ninf = eminus;  # direction to infinity\n\njulia> t = 0.1*(e1) ∧ ninf;  # translator-like bivector\n\njulia> T = exp(t);\n\njulia> p = e1;  # simple direction-grade representative\n\njulia> p2 = T ≀ p; p2 isa MultiVector; true\ntrue","category":"page"},{"location":"recipes/#Tips","page":"Recipes","title":"Tips","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"Use matrix(mv) and vector(mv) for sanity checks against linear algebra operations.\nPrefer small angles and normalized elements in doctests to keep outputs stable.\nWhen doctests are sensitive to printed formatting, write to an IOBuffer and assert true.","category":"page"},{"location":"recipes/#More-small-patterns","page":"Recipes","title":"More small patterns","text":"","category":"section"},{"location":"recipes/#PGA:-motor-inverse-round-trip","page":"Recipes","title":"PGA: motor inverse round-trip","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3, e0 = basevector(pga,1), basevector(pga,2), basevector(pga,3), basevector(pga,:e0);\n\njulia> B = (π/10) * (e1 ∧ e2);\n\njulia> T = 0.02 * (e0 ∧ e1);\n\njulia> M = exp(B + T);\n\njulia> v = e1 + 0.3e2 + 0.2e3;\n\njulia> v_back = (~M) ≀ (M ≀ v); true\ntrue","category":"page"},{"location":"recipes/#Cl3:-simple-rotation-around-z-axis","page":"Recipes","title":"Cl3: simple rotation around z-axis","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> cl3 = CliffordAlgebra(3);\n\njulia> e1, e2, e3 = cl3.e1, cl3.e2, cl3.e3;\n\njulia> B = (π/3) * (e1 ∧ e2);\n\njulia> R = exp(B);\n\njulia> v = e1;\n\njulia> v_rot = R ≀ v; true\ntrue","category":"page"},{"location":"recipes/#STA:-compose-small-boosts","page":"Recipes","title":"STA: compose small boosts","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> sta = CliffordAlgebra(:Spacetime);\n\njulia> t, x, y = basevector(sta,:t), basevector(sta,:x), basevector(sta,:y);\n\njulia> Bx = 0.05 * (t ∧ x);\n\njulia> By = 0.03 * (t ∧ y);\n\njulia> R = exp(By) * exp(Bx);\n\njulia> v = t + 0.1x + 0.2y;\n\njulia> vb = R ≀ v; true\ntrue","category":"page"},{"location":"recipes/#Advanced-patterns","page":"Recipes","title":"Advanced patterns","text":"","category":"section"},{"location":"recipes/#CGA:-circle–line-intersection-(meet)","page":"Recipes","title":"CGA: circle–line intersection (meet)","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> cga = CliffordAlgebra(:CGA3D);\n\njulia> e1, e2, e3 = basevector(cga,1), basevector(cga,2), basevector(cga,3);\n\njulia> C = (e1 ∧ e2) + (e2 ∧ e3);   # mock circle-like blade\n\njulia> L = e1 ∧ e2;                 # mock line-like blade\n\njulia> inter = C ∨ L; inter isa MultiVector; true\ntrue","category":"page"},{"location":"recipes/#CGA:-sphere–plane-intersection-(meet)","page":"Recipes","title":"CGA: sphere–plane intersection (meet)","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> cga = CliffordAlgebra(:CGA3D);\n\njulia> e1, e2, e3 = basevector(cga,1), basevector(cga,2), basevector(cga,3);\n\njulia> S = (e1 ∧ e2 ∧ e3) + (e1 ∧ e2);  # mock sphere-like multivector\n\njulia> Π = e3;                           # mock plane-like blade\n\njulia> inter = S ∨ Π; inter isa MultiVector; true\ntrue","category":"page"},{"location":"recipes/#PGA:-projection-and-distance-sketches","page":"Recipes","title":"PGA: projection and distance sketches","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3 = basevector(pga,1), basevector(pga,2), basevector(pga,3);\n\njulia> line = e1 ∧ e2;   # x–y axis line-like\n\njulia> plane = e3;       # z=0 plane-like\n\njulia> v = e1 + 2e2 + 3e3;\n\njulia> proj_line = (line ⨼ v); proj_plane = (plane ⨼ v); true\ntrue","category":"page"},{"location":"recipes/#Cl3/PGA:-interpolate-between-rotations/motors","page":"Recipes","title":"Cl3/PGA: interpolate between rotations/motors","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> cl3 = CliffordAlgebra(3);\n\njulia> e1, e2, e3 = cl3.e1, cl3.e2, cl3.e3;\n\njulia> B1 = (π/8) * (e1 ∧ e2);\n\njulia> B2 = (π/5) * (e2 ∧ e3);\n\njulia> t = 0.3;\n\njulia> R = exp((1-t)*B1 + t*B2);\n\njulia> v = e1 + e2;\n\njulia> v2 = R ≀ v; true\ntrue","category":"page"},{"location":"recipes/#STA:-electromagnetic-field-transform-under-boost","page":"Recipes","title":"STA: electromagnetic field transform under boost","text":"","category":"section"},{"location":"recipes/","page":"Recipes","title":"Recipes","text":"julia> using CliffordAlgebras\n\njulia> sta = CliffordAlgebra(:Spacetime);\n\njulia> t, x, y, z = basevector(sta,:t), basevector(sta,:x), basevector(sta,:y), basevector(sta,:z);\n\njulia> F = (t ∧ x) + (y ∧ z);   # mock EM field bivector (E along x, B along x)\n\njulia> Bx = 0.1 * (t ∧ x);\n\njulia> R = exp(Bx);\n\njulia> Fp = R ≀ F; Fp isa MultiVector; true\ntrue","category":"page"},{"location":"tutorial/#Tutorial:-Getting-Started-with-CliffordAlgebras.jl","page":"Tutorial","title":"Tutorial: Getting Started with CliffordAlgebras.jl","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial will walk you through the basics of using CliffordAlgebras.jl for geometric algebra computations.","category":"page"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras","category":"page"},{"location":"tutorial/#Lesson-1:-Creating-Your-First-Algebra","page":"Tutorial","title":"Lesson 1: Creating Your First Algebra","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's start with the simplest non-trivial Clifford algebra, Cl(2,0,0):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras\n\njulia> cl2 = CliffordAlgebra(2)\nCl(2,0,0)\n\njulia> io = IOBuffer(); cayleytable(io, cl2); true\ntrue","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This creates an algebra with 2 basis vectors e₁ and e₂ that both square to +1.","category":"page"},{"location":"tutorial/#Lesson-2:-Basis-Elements","page":"Tutorial","title":"Lesson 2: Basis Elements","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Every Clifford algebra has 2ⁿ basis elements for n generators:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras; cl2 = CliffordAlgebra(2);\n\njulia> scalar_unit, e1, e2, e12 = cl2.𝟏, cl2.e1, cl2.e2, cl2.e1e2;\n\njulia> e1*e1 == cl2.𝟏\ntrue\n\njulia> e2*e2 == cl2.𝟏\ntrue\n\njulia> e1*e2 == e12\ntrue\n\njulia> e2*e1 == -e12\ntrue","category":"page"},{"location":"tutorial/#Lesson-3:-Building-Multivectors","page":"Tutorial","title":"Lesson 3: Building Multivectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A general multivector combines elements of different grades:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras; cl2 = CliffordAlgebra(2); e1, e2, e12 = cl2.e1, cl2.e2, cl2.e1e2;\n\njulia> mv = 2.0 + 3.0*e1 + 4.0*e2 + 5.0*e12;\n\njulia> scalar(mv)\n2.0\n\njulia> grade(mv, 1) isa MultiVector\ntrue\n\njulia> grade(mv, 2) isa MultiVector\ntrue","category":"page"},{"location":"tutorial/#Lesson-4:-The-Geometric-Product","page":"Tutorial","title":"Lesson 4: The Geometric Product","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The geometric product is the fundamental operation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras; cl2 = CliffordAlgebra(2); e1, e2 = cl2.e1, cl2.e2;\n\njulia> a = 2*e1 + 3*e2; b = 4*e1 + 5*e2;\n\njulia> result = a * b; (scalar(result), grade(result, 2) isa MultiVector)\n(23, true)","category":"page"},{"location":"tutorial/#Lesson-5:-Specialized-Products","page":"Tutorial","title":"Lesson 5: Specialized Products","text":"","category":"section"},{"location":"tutorial/#Exterior-Product-(Wedge-Product)","page":"Tutorial","title":"Exterior Product (Wedge Product)","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Creates higher-grade elements:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras; cl2 = CliffordAlgebra(2); e1, e2, e12 = cl2.e1, cl2.e2, cl2.e1e2;\n\njulia> area_element = e1 ∧ e2; area_element == e12\ntrue\n\njulia> e1 ∧ e1\n0","category":"page"},{"location":"tutorial/#Interior-Products","page":"Tutorial","title":"Interior Products","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Various ways to contract multivectors:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras; cl2 = CliffordAlgebra(2); e1, e2 = cl2.e1, cl2.e2; a = 2*e1 + 3*e2; b = 4*e1 + 5*e2;\n\njulia> fat_dot = a ⋅ b; fat_dot isa MultiVector\ntrue\n\njulia> scalar_prod = a ⋆ b; scalar(scalar_prod) isa Real\ntrue","category":"page"},{"location":"tutorial/#Lesson-6:-Rotations-in-2D","page":"Tutorial","title":"Lesson 6: Rotations in 2D","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One of the most important applications is representing rotations:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras; cl2 = CliffordAlgebra(2); e1, e2, e12 = cl2.e1, cl2.e2, cl2.e1e2;\n\njulia> v = e1; angle = π/4; B = angle * e12;\n\njulia> rotor = exp(B/2);\n\njulia> rotated_v = rotor ≀ v;\n\njulia> (isgrade(rotated_v, 1), isapprox(norm(rotated_v), norm(v)))\n(true, true)","category":"page"},{"location":"tutorial/#ASCII-only-usage","page":"Tutorial","title":"ASCII-only usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If typing Unicode operators is inconvenient, use the function forms:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras; cl2 = CliffordAlgebra(2);\n\njulia> a = 1 + cl2.e1; b = 1 + cl2.e2;\n\njulia> gp = *(a, b);  # geometric product\n\njulia> wedge = CliffordAlgebras.exteriorprod(cl2.e1, cl2.e2);\n\njulia> dot = CliffordAlgebras.fatdotprod(a, b);\n\njulia> scalarpart = CliffordAlgebras.scalarprod(a, b);\n\njulia> (gp isa MultiVector) && (wedge == cl2.e1e2) && (scalar(scalarpart) isa Real)\ntrue","category":"page"},{"location":"tutorial/#Lesson-7:-Working-with-3D-Space","page":"Tutorial","title":"Lesson 7: Working with 3D Space","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's move to three dimensions:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cl3 = CliffordAlgebra(3)\n\n# Create some 3D vectors\nx_axis = cl3.e1\ny_axis = cl3.e2  \nz_axis = cl3.e3\n\n# Create a general vector\nv3d = 1*x_axis + 2*y_axis + 3*z_axis\n\n# The pseudoscalar in 3D\nI3 = cl3.e1e2e3\nprintln(\"3D pseudoscalar: \", I3)\nprintln(\"I³² = \", I3 * I3)  # Should be -1\n\n# Duality operation\ndual_v = dual(v3d)\nprintln(\"Dual of vector: \", dual_v)","category":"page"},{"location":"tutorial/#Minimal-PGA/CGA-examples","page":"Tutorial","title":"Minimal PGA/CGA examples","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e0 = basevector(pga, :e0);  # null basis vector in PGA\n\njulia> scalar(e0*e0)\n0\n\njulia> cga = CliffordAlgebra(:CGA3D);\n\njulia> eplus = basevector(cga, :e₊); eminus = basevector(cga, :e₋);\n\njulia> (scalar(eplus*eplus), scalar(eminus*eminus))\n(1, -1)","category":"page"},{"location":"tutorial/#CGA:-Euclidean-rotation-via-rotor","page":"Tutorial","title":"CGA: Euclidean rotation via rotor","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using CliffordAlgebras\n\njulia> cga = CliffordAlgebra(:CGA3D);\n\njulia> e1, e2 = basevector(cga, :e1), basevector(cga, :e2);\n\njulia> v = e1;  # unit vector along x\n\njulia> B = (π/4) * (e1 ∧ e2);  # rotate by 45° in the e1∧e2 plane\n\njulia> R = exp(B/2);\n\njulia> v_rot = R ≀ v;\n\njulia> isgrade(v_rot, 1) && isapprox(norm(v_rot), norm(v))\ntrue","category":"page"},{"location":"tutorial/#Lesson-8:-Spacetime-Algebra","page":"Tutorial","title":"Lesson 8: Spacetime Algebra","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Spacetime algebra uses signature (1,3,0):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sta = CliffordAlgebra(:Spacetime)\n\n# Basis vectors\nt = sta.t  # Time (squares to +1)\nx = sta.x  # Space (squares to -1) \ny = sta.y\nz = sta.z\n\n# Create a spacetime event\nevent = 5*t + 3*x + 4*y + 0*z\n\n# Compute the spacetime interval\ninterval = scalar(event * reverse(event))\nprintln(\"Spacetime interval: \", interval)\n\n# Check if timelike, spacelike, or lightlike\nif interval > 0\n    println(\"Timelike separation\")\nelseif interval < 0\n    println(\"Spacelike separation\")  \nelse\n    println(\"Lightlike separation\")\nend","category":"page"},{"location":"tutorial/#Lesson-9:-Advanced-Operations","page":"Tutorial","title":"Lesson 9: Advanced Operations","text":"","category":"section"},{"location":"tutorial/#Inverse-and-Division","page":"Tutorial","title":"Inverse and Division","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cl2 = CliffordAlgebra(2)\nmv = 2 + 3*cl2.e1\n\n# Compute inverse\ninv_mv = inv(mv)\nprintln(\"Inverse: \", inv_mv)\n\n# Verify: mv * inv(mv) should be 1\nprintln(\"mv * inv(mv) = \", mv * inv_mv)\n\n# Division\na = 1 + cl2.e1\nb = 2 + cl2.e2\nquotient = a / b\nprintln(\"a / b = \", quotient)","category":"page"},{"location":"tutorial/#Exponential-Function","page":"Tutorial","title":"Exponential Function","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Exponential of bivectors gives rotors\nB = π/6 * cl2.e1e2\nrotor = exp(B)\n\n# Exponential of vectors in hyperbolic case\nhyp = CliffordAlgebra(1, 1)  # One positive, one negative\nboost_generator = hyp.e1e2\nboost = exp(0.5 * boost_generator)  # Hyperbolic rotation","category":"page"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Explore conformal geometric algebra for geometric modeling\nLearn about projective geometric algebra for computer graphics\nStudy spacetime algebra for relativistic physics\nInvestigate the package's performance features for large computations","category":"page"},{"location":"tutorial/#Common-Pitfalls","page":"Tutorial","title":"Common Pitfalls","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Forgetting anticommutativity: Remember that e1 * e2 = -e2 * e1\nMixing algebras: You can't directly combine multivectors from different algebras\nType stability: Use prune() carefully as it's not type-stable\nGrade confusion: Remember that the geometric product of two vectors has both grade 0 and grade 2 parts","category":"page"},{"location":"tutorial/#Performance-Tips","page":"Tutorial","title":"Performance Tips","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use type-stable operations when possible\nLeverage the sparse representation for efficiency\nPre-compute rotors for repeated transformations\nUse @inferred to check type stability in performance-critical code","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"This page lists the public API and selected internal functions for advanced users.","category":"page"},{"location":"api/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/#CliffordAlgebras.CliffordAlgebra","page":"API Reference","title":"CliffordAlgebras.CliffordAlgebra","text":"CliffordAlgebra(Npos::Integer, Nneg::Integer, Nzero::Integer, S::NTuple(N,Symbol))\n\nSingleton instance of the type CliffordAlgebra that describes a geometric algebra with the signature (Npos,Nneg,Nzero), base symbols S. The base symbols are in order of the signature.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliffordAlgebras.CliffordAlgebra-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"CliffordAlgebras.CliffordAlgebra","text":"CliffordAlgebra(Npos::Integer, Nneg::Integer, Nzero::Integer)\n\nGenerates a geometric algebra with signature (Npos,Nneg,Nzero).\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.CliffordAlgebra-Tuple{Integer, Integer}","page":"API Reference","title":"CliffordAlgebras.CliffordAlgebra","text":"CliffordAlgebra(Npos::Integer, Nneg::Integer)\n\nGenerates a geometric algebra with signature (Npos,Nneg,0).\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.CliffordAlgebra-Tuple{Integer}","page":"API Reference","title":"CliffordAlgebras.CliffordAlgebra","text":"CliffordAlgebra(N::Integer)\n\nGenerates a geometric algebra with signature (N,0,0).\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.CliffordAlgebra-Tuple{Symbol}","page":"API Reference","title":"CliffordAlgebras.CliffordAlgebra","text":"CliffordAlgebra(a::Symbol)\n\nGenerates a predefined algebra from a identifier. Known algebras are     - :Hyperbolic or :Hyper     - :Complex or :ℂ     - :Dual or :Grassmann     - :Grassmann2D or :G2     - :Grassmann3D or :G3     - :Quaternions or :ℍ     - :Cl2 and :Cl3     - :Spacetime     - :PGA2D or :Projective2D or :Plane2D     - :PGA3D or :Projective3D or :Plane3D     - :CGA2D or :Conformal2D     - :CGA3D or :Conformal3D     - :DCGA3D or :DoubleConformal3D     - :TCGA3D or :TripleConformal3D     - :DCGSTA or :DoubleConformalSpacetime     - :QCGA or :QuadricConformal\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.MultiVector","page":"API Reference","title":"CliffordAlgebras.MultiVector","text":"MultiVector{CA,T,BI}\n\nType for a multivector belonging to the algebra CA<:CliffordAlgebra with vector coefficients of type T. Coefficients are stored using a sparse coding, and only the coefficients of the basis indices stored in the tuple BI are considered.\n\n\n\n\n\n","category":"type"},{"location":"api/#CliffordAlgebras.MultiVector-Union{Tuple{N}, Tuple{CA}, Tuple{Type{CA}, NTuple{N, var\"#s22\"} where var\"#s22\"<:Real}} where {CA<:CliffordAlgebra, N}","page":"API Reference","title":"CliffordAlgebras.MultiVector","text":"MultiVector(::CliffordAlgebra, v::NTuple{N,T}) where {N,T<:Real}\nMultiVector(::Type{<:CliffordAlgebra}, v::NTuple{N,T}) where {N,T<:Real}\n\nCreates a MultiVector by converting the provided vector v to a 1-vector. The internal storage type of the MultiVector is T.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.MultiVector-Union{Tuple{T}, Tuple{CA}, Tuple{Type{CA}, T}} where {CA<:CliffordAlgebra, T<:Real}","page":"API Reference","title":"CliffordAlgebras.MultiVector","text":"MultiVector(::CliffordAlgebra, a::Real)\nMultiVector(::Type{<:CliffordAlgebra}, a::Real)\n\nCreates a MultiVector from the real number a with only a scalar component. The internal storage type of the MultiVector is the type of a.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:*-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"Base.:*","text":"a * b\n\nCompute the geometric product of multivectors a and b.\n\nThe geometric product is the fundamental operation in Clifford algebra, combining the inner and outer products. It encodes both the magnitude and orientation relationships between multivectors.\n\nMathematical Definition\n\nThe geometric product decomposes as:\n\na * b = a·b + a∧b\n\nwhere · is the inner product and ∧ is the exterior product.\n\nProperties\n\nAssociative: (a * b) * c = a * (b * c)\nDistributive: a * (b + c) = a * b + a * c\nGenerally non-commutative: a * b ≠ b * a in general\nFor vectors: u * v = u·v + u∧v\n\nSpecial Cases\n\nParallel vectors: u * v = u·v (pure scalar)\nOrthogonal vectors: u * v = u∧v (pure bivector)\nSame vector: v * v = |v|² (squared magnitude)\n\nExamples\n\ncl3 = CliffordAlgebra(3)\ne1, e2 = cl3.e1, cl3.e2\n\n# Vector geometric product\nu = 2*e1 + 3*e2\nv = 4*e1 + 5*e2\nresult = u * v  # Returns scalar part (dot) + bivector part (wedge)\n\n# Basis vector products\ne1 * e1  # Returns 1 (squares to +1 in Euclidean signature)\ne1 * e2  # Returns e1e2 (creates bivector)\ne2 * e1  # Returns -e1e2 (anticommutative for orthogonal vectors)\n\nSee also: ∧, ⋅, ⨼, ⨽\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:/-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"Base.:/","text":"a / b\n(/)(a::MultiVector{CA}, b::MuliVector{CA}) where CA\n\nCalculates the MultiVector quotient a/b by evaluating a*inv(b).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:\\-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"Base.:\\","text":"a \\ b\n(\\)(a::MultiVector{CA}, b::MultiVector{CA}) where CA\n\nLeft division defined as inv(a) * b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:~-Tuple{MultiVector}","page":"API Reference","title":"Base.:~","text":"~a\n(~)(::MultiVector)\n\nReturns the reversed MultiVector reverse(a).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.conj-Tuple{MultiVector}","page":"API Reference","title":"Base.conj","text":"conj(mv::MultiVector)\n\nReturn the conjugate of the MultiVector, i.e. reverse(grin(mv)).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{MultiVector}","page":"API Reference","title":"Base.inv","text":"inv(::MultiVector)\n\nFinds the inverse of the MultiVector. If no inverse exists a SingularException is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.isapprox-Tuple{MultiVector, MultiVector}","page":"API Reference","title":"Base.isapprox","text":"isapprox(mv1::MultiVector, mv2::MultiVector; kw...)\n\nCheck if mv1 and mv2 belong to the same algebra and their coefficients are close.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.reverse-Union{Tuple{MultiVector{CA, T, BI, K}}, Tuple{K}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI, K}","page":"API Reference","title":"Base.reverse","text":"reverse(::MultiVector)\n\nReturns the MultiVector that has all the basis vector products reversed.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:×₊-Union{Tuple{Tb}, Tuple{Ta}, Tuple{CA}, Tuple{MultiVector{CA, Ta}, MultiVector{CA, Tb}}} where {CA, Ta, Tb}","page":"API Reference","title":"CliffordAlgebras.:×₊","text":"a ×₊ b\n\nCalculates the anti-commutator ab+ba of two MultiVectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:×₋-Union{Tuple{Tb}, Tuple{Ta}, Tuple{CA}, Tuple{MultiVector{CA, Ta}, MultiVector{CA, Tb}}} where {CA, Ta, Tb}","page":"API Reference","title":"CliffordAlgebras.:×₋","text":"a ×₋ b\n\nCalculates the commutator ab-ba of two MultiVectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:∧-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"CliffordAlgebras.:∧","text":"a ∧ b\n\nCompute the exterior (wedge) product of multivectors a and b.\n\nThe exterior product is anti-commutative and associative, creating higher-grade elements. It represents the \"oriented volume\" spanned by the input multivectors.\n\nProperties\n\nAnti-commutative: a ∧ b = -b ∧ a\nAssociative: (a ∧ b) ∧ c = a ∧ (b ∧ c)\nNilpotent: a ∧ a = 0 for any multivector\nGrade additive: grade(a ∧ b) = grade(a) + grade(b) (for homogeneous multivectors)\n\nExamples\n\ncl3 = CliffordAlgebra(3)\ne1, e2, e3 = cl3.e1, cl3.e2, cl3.e3\n\n# Vector exterior products create bivectors (oriented areas)\ne1 ∧ e2  # Creates the e1e2 bivector\n\n# Bivector ∧ vector creates trivector (oriented volume) \n(e1 ∧ e2) ∧ e3  # Creates the e1e2e3 trivector (pseudoscalar)\n\n# Self-exterior is always zero\ne1 ∧ e1  # Returns 0\n\nSee also: ⋅, ⨼, ⨽, *\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:∨-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"CliffordAlgebras.:∨","text":"a ∨ b\n\nCalculates the regressive product of the MultiVectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:≀-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"CliffordAlgebras.:≀","text":"a ≀ b\n\nCalculates the sandwich product a*b*reverse(a) for two MultiVectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:⋅-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"CliffordAlgebras.:⋅","text":"a ⋅ b\n\nCompute the \"fat dot\" product between multivectors a and b.\n\nThe fat dot product is the symmetric part of the geometric product, extracting components where the grade difference is minimized. It's related to the  generalized inner product in geometric algebra.\n\nMathematical Definition\n\nFor homogeneous multivectors of grades p and q:\n\na ⋅ b = ⟨ab⟩_{|p-q|}\n\nProperties\n\nSymmetric: a ⋅ b = b ⋅ a\nLinear in both arguments\nGrade selective: extracts the |grade(a) - grade(b)| part\n\nExamples\n\ncl3 = CliffordAlgebra(3)\ne1, e2 = cl3.e1, cl3.e2\n\n# Vector dot product gives scalar\nv1 = e1 + e2\nv2 = 2*e1 + 3*e2\nscalar_part = v1 ⋅ v2  # Returns 5.0 (the scalar part)\n\n# Mixed grade operations\nbivector = e1 ∧ e2\nvector = e1\nresult = bivector ⋅ vector  # Returns -e2\n\nSee also: ∧, ⨼, ⨽, ⋆\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:⋆-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"CliffordAlgebras.:⋆","text":"a ⋆ b\n\nCalculates the scalar product of the MultiVectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:⨼-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"CliffordAlgebras.:⨼","text":"a ⨼ b\n\nCalculates the left contraction of the MultiVectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.:⨽-Union{Tuple{CA}, Tuple{MultiVector{CA}, MultiVector{CA}}} where CA","page":"API Reference","title":"CliffordAlgebras.:⨽","text":"a ⨽ b\n\nCalculates the right contraction of the MultiVectors a and b.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.algebra-Union{Tuple{Type{<:MultiVector{CA}}}, Tuple{CA}} where CA","page":"API Reference","title":"CliffordAlgebras.algebra","text":"algebra(::MultiVector)\nalgebra(::Type{<:MultiVector})\n\nReturns the CliffordAlgebra instance to which the MultiVector belongs.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.baseindices-Union{Tuple{Type{<:MultiVector{CA, T, BI}}}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI}","page":"API Reference","title":"CliffordAlgebras.baseindices","text":"baseindices(::MultiVector)\nbaseindices(::Type{<:MultiVector})\n\nReturns the indices for the sparse MultiVector basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.basesymbol-Tuple{Type{<:CliffordAlgebra}, Integer}","page":"API Reference","title":"CliffordAlgebras.basesymbol","text":"basesymbol(::CliffordAlgebra, n::Integer)\nbasesymbol(::Type{<:CliffordAlgebra}, n::Integer)\n\nReturns the symbol used for the n-th basis multivector of the algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.basevector-Tuple{Type{<:CliffordAlgebra}, Integer}","page":"API Reference","title":"CliffordAlgebras.basevector","text":"basevector(::CliffordAlgebra, n::Integer)\nbasevector(::Type{<:CliffordAlgebra}, n::Integer)\n\nReturns the n-th basis MultiVector of the given CliffordAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.basevector-Tuple{Type{<:CliffordAlgebra}, Symbol}","page":"API Reference","title":"CliffordAlgebras.basevector","text":"basevector(::CliffordAlgebra, name::Symbol)\nbasevector(::Type{<:CliffordAlgebra}, name::Symbol)\n\nReturns the basis MultiVector with the specified name from the given Clifford Algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.cayleytable-Tuple{IO, CliffordAlgebra}","page":"API Reference","title":"CliffordAlgebras.cayleytable","text":"cayleytable(io::IO, ca::CliffordAlgebra)\ncayleytable(io::IO, CA::Type{<:CliffordAlgebra})\n\nGenerates a Cayley table view of the algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.character-Tuple{Type{<:CliffordAlgebra}}","page":"API Reference","title":"CliffordAlgebras.character","text":"character(::CliffordAlgebra)\ncharacter(::Type{<:CliffordAlgebra})\n\nReturns the square of the pseudoscalar of the algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.coefficient-Union{Tuple{T}, Tuple{CA}, Tuple{MultiVector{CA, T}, Integer}} where {CA, T}","page":"API Reference","title":"CliffordAlgebras.coefficient","text":"coefficient(::MultiVector, n::Integer)\n\nReturns the multivector coefficients for the n-th basis vector. Returns 0 if n is out of bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.coefficient-Union{Tuple{T}, Tuple{CA}, Tuple{MultiVector{CA, T}, Symbol}} where {CA, T}","page":"API Reference","title":"CliffordAlgebras.coefficient","text":"coefficient(::MultiVector, s::Symbol)\n\nReturns the multivector coefficients for the basis vector belonging to the symbol s. Returns 0 if the symbol is not a valid basis symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.coefficients-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.coefficients","text":"coefficients(::MultiVector)\n\nReturns the sparse coefficients of the MultiVector.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.dimension-Tuple{Type{<:CliffordAlgebra}}","page":"API Reference","title":"CliffordAlgebras.dimension","text":"dimension(::CliffordAlgebra)\ndimension(::Type{<:CliffordAlgebra})\n\nReturns the dimension of the algebra, i.e. the number of coefficients in a general multivector.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.dual-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.dual","text":"dual(mv::MultiVector)\n\nReturns the Poincaré dual of the MultiVector, such that for all basis MultiVectors mv * dual(mv) = pseudoscalar. Dual is a linear map and the images of other MultiVectors follow from the images of the basis MultiVectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.even-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.even","text":"even(::MultiVector)\n\nReturns the even grade projection of the MultiVector.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.extend-Union{Tuple{MultiVector{CA, T}}, Tuple{T}, Tuple{CA}} where {CA, T}","page":"API Reference","title":"CliffordAlgebras.extend","text":"extend(::MultiVector)\n\nReturns a new MultiVector with a non-sparse coefficient coding. This can be useful to manage type stability.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.grade-Tuple{MultiVector, Integer}","page":"API Reference","title":"CliffordAlgebras.grade","text":"grade(::MultiVector, k::Integer)\n\nProjects the MultiVector onto the k-vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.grin-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.grin","text":"grin(mv::MultiVector)\n\nReturns the grade involution of the MultiVector, i.e. even(mv) - odd(mv).\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.isgrade-Tuple{MultiVector, Integer}","page":"API Reference","title":"CliffordAlgebras.isgrade","text":"isgrade(::MultiVector, k::Integer)\n\nReturns true if the MultiVector is of grade k, false if not.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.matrix-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.matrix","text":"matrix(::MultiVector)\n\nReturns the matrix algebra representation of the MultiVector.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.maxgrade-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.maxgrade","text":"maxgrade(::MultiVector ; rtol = 1e-8)\n\nProjects the MultiVector onto the subspace of the largest grade with non-vanishing norm. Returns a tuple of the resulting multivector and its grade.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.mingrade-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.mingrade","text":"mingrade(::MultiVector ; rtol = 1e-8)\n\nProjects the MultiVector onto the subspace of the largest grade with non-vanishing norm.  Returns a tuple of the resulting multivector and its grade.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.odd-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.odd","text":"odd(::MultiVector)\n\nReturns the odd grade projection of the MultiVector.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.order-Union{Tuple{Type{<:CliffordAlgebra{Np, Nn, Nz}}}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz}","page":"API Reference","title":"CliffordAlgebras.order","text":"order(::CliffordAlgebra)\norder(::Type{<:CliffordAlgebra})\n\nReturns the order of the algebra. The order is the sum of the signature and the dimension of the underlying 1-vector space and the maximum grade for multivectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.outermorphism-Tuple{AbstractMatrix, MultiVector}","page":"API Reference","title":"CliffordAlgebras.outermorphism","text":"outermorphism(A::AbstractMatrix, mv::MultiVector)\n\nCalculates the outermorphism f of the MultiVector defined by f(v) = Av if v is in the grade-1 subspace of the algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.polarize-Union{Tuple{MultiVector{CA}}, Tuple{CA}} where CA","page":"API Reference","title":"CliffordAlgebras.polarize","text":"polarize(mv::MultiVector)\nmv'\n\nCalculates the polarization of the MultiVector, i.e. mv * pseudoscalar.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.prune-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.prune","text":"prune(::MultiVector ; rtol = 1e-8 )\n\nReturns a new MultiVector with all basis vectors removed from the sparse basis whose coefficients fall below the relative magnitude threshold. This function is not type stable, because the return type depends on the sparse basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.pseudoscalar-Tuple{Type{<:CliffordAlgebra}}","page":"API Reference","title":"CliffordAlgebras.pseudoscalar","text":"pseudoscalar(::CliffordAlgebra)\npseudoscalar(::Type{<:CliffordAlgebra})\n\nReturns the pseudoscalar of the given algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.scalar-Union{Tuple{MultiVector{CA, T, BI}}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI}","page":"API Reference","title":"CliffordAlgebras.scalar","text":"scalar(mv::MultiVector)\n\nReturns the scalar component of the multivector. The result if of the internal storage type eltype(mv).\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.signature-Union{Tuple{Type{<:CliffordAlgebra{Np, Nn, Nz}}}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz}","page":"API Reference","title":"CliffordAlgebras.signature","text":"signature(::CliffordAlgebra)\nsignature(::Type{<:CliffordAlgebra})\n\nReturns the signature of the algebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.signaturetable-Tuple{IO, CliffordAlgebra}","page":"API Reference","title":"CliffordAlgebras.signaturetable","text":"signaturetable(io::IO, ca::CliffordAlgebra)\nsignaturetable(io::IO, CA::Type{<:CliffordAlgebra})\n\nPrints the 1-vector basis symbols and their squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.vector-Tuple{MultiVector}","page":"API Reference","title":"CliffordAlgebras.vector","text":"vector(::MultiVector)\n\nReturns the non-sparse vector representation of the MutliVector.\n\n\n\n\n\n","category":"method"},{"location":"api/#CliffordAlgebras.Λᵏ-Union{Tuple{k}, Tuple{CA}, Tuple{MultiVector{CA}, Val{k}}} where {CA, k}","page":"API Reference","title":"CliffordAlgebras.Λᵏ","text":"Λᵏ(::MultiVector, ::Val{k}) where k\nΛᵏ(::MultiVector, k::Integer)\n\nProjects the MultiVector onto k-vectors. Similar to grade(mv,k), but uses @generated code and compile time optimizations.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.norm-Union{Tuple{MultiVector{CA}}, Tuple{CA}} where CA","page":"API Reference","title":"LinearAlgebra.norm","text":"norm(::MultiVector)\n\nCalculates the MultiVector norm defined as sqrt(scalar(mv*reverse(mv))).\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.norm_sqr-Union{Tuple{MultiVector{CA, T, BI, K}}, Tuple{K}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI, K}","page":"API Reference","title":"LinearAlgebra.norm_sqr","text":"norm_sqr(::MultiVector)\n\nCalculates the MultiVector squared norm defined as grade(mv*reverse(mv),0)\n\n\n\n\n\n","category":"method"},{"location":"api/#Internal-API-(advanced)","page":"API Reference","title":"Internal API (advanced)","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The following internal item is documented for completeness:","category":"page"},{"location":"api/#CliffordAlgebras._multtable_cache","page":"API Reference","title":"CliffordAlgebras._multtable_cache","text":"Internal cache for multiplication tables keyed by the CliffordAlgebra type.\n\n\n\n\n\n","category":"constant"},{"location":"cheatsheet/#Cheat-Sheet","page":"Cheat Sheet","title":"Cheat Sheet","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"A quick reference for common tasks, operators, and patterns in CliffordAlgebras.jl.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia> using CliffordAlgebras; using LinearAlgebra; true\ntrue","category":"page"},{"location":"cheatsheet/#Algebra-creation","page":"Cheat Sheet","title":"Algebra creation","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia> Cl = CliffordAlgebra;  # alias\n\njulia> cl2 = Cl(2); cl3 = Cl(3); sta = Cl(:Spacetime); pga = Cl(:PGA3D); cga = Cl(:CGA3D); true\ntrue","category":"page"},{"location":"cheatsheet/#Unicode-operators-(with-ASCII-fallbacks)","page":"Cheat Sheet","title":"Unicode operators (with ASCII fallbacks)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Geometric product: a * b\nExterior (wedge): a ∧ b — ASCII: CliffordAlgebras.exteriorprod(a,b)\nRegressive: a ∨ b — ASCII: CliffordAlgebras.regressiveprod(a,b)\nFat dot: a ⋅ b — ASCII: CliffordAlgebras.fatdotprod(a,b)\nScalar: a ⋆ b — ASCII: CliffordAlgebras.scalarprod(a,b)\nLeft contraction: a ⨼ b — ASCII: CliffordAlgebras.leftcontractionprod(a,b)\nRight contraction: a ⨽ b — ASCII: CliffordAlgebras.rightcontractionprod(a,b)\nCommutator: a ×₋ b — ASCII: CliffordAlgebras.commutatorprod(a,b)\nAnti-commutator: a ×₊ b — ASCII: CliffordAlgebras.anticommutatorprod(a,b)\nSandwich (conjugation): A ≀ X — ASCII: CliffordAlgebras.sandwichproduct(A,X)","category":"page"},{"location":"cheatsheet/#Working-with-multivectors","page":"Cheat Sheet","title":"Working with multivectors","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia> cl3 = CliffordAlgebra(3);\n\njulia> e1, e2, e3 = cl3.e1, cl3.e2, cl3.e3;\n\njulia> mv = 1 + 2e1 + 3e2 + (e1 ∧ e2);  # 0-,1-,2- grades\n\njulia> scalar(mv); grade(mv,2); even(mv); odd(mv); ~mv; dual(mv); true\ntrue","category":"page"},{"location":"cheatsheet/#Rotors-and-motors-(quick)","page":"Cheat Sheet","title":"Rotors and motors (quick)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia> cl3 = CliffordAlgebra(3);\n\njulia> B = (π/4) * (cl3.e1 ∧ cl3.e2); R = exp(B);\n\njulia> v = cl3.e1; v_rot = R ≀ v; true\ntrue","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"PGA motor (rotation+translation):","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia> pga = CliffordAlgebra(:PGA3D);\n\njulia> e1, e2, e3, e0 = basevector(pga,1), basevector(pga,2), basevector(pga,3), basevector(pga,:e0);\n\njulia> B = (π/12)*(e1 ∧ e2); T = 0.05*(e0 ∧ e1); M = exp(B+T);\n\njulia> v = e1 + 2e2; v2 = M ≀ v; true\ntrue","category":"page"},{"location":"cheatsheet/#Outermorphism-(linear-transform)","page":"Cheat Sheet","title":"Outermorphism (linear transform)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia> cl2 = CliffordAlgebra(2); v = cl2.e1 + cl2.e2;\n\njulia> θ = π/6; R = [cos(θ) -sin(θ); sin(θ) cos(θ)];\n\njulia> v2 = outermorphism(R, v); true\ntrue","category":"page"},{"location":"cheatsheet/#Tables-and-signatures","page":"Cheat Sheet","title":"Tables and signatures","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia> cl2 = CliffordAlgebra(2);\n\njulia> io = IOBuffer(); signaturetable(io, cl2); cayleytable(io, cl2); true\ntrue","category":"page"},{"location":"cheatsheet/#Quick-facts","page":"Cheat Sheet","title":"Quick facts","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Algebra dimension for signature (p,q,r) with n=p+q+r is 2^n.\nNumber of grade-k elements is C(n,k).\nPseudoscalar I has grade n; I^2 = character(algebra).\nNull basis vectors (r>0) square to 0 and represent infinity/conformal components depending on algebra.","category":"page"},{"location":"mathematical_background/#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"This section provides the mathematical foundations for understanding Clifford algebras and their implementation in CliffordAlgebras.jl.","category":"page"},{"location":"mathematical_background/#What-is-a-Clifford-Algebra?","page":"Mathematical Background","title":"What is a Clifford Algebra?","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"A Clifford algebra, also known as a geometric algebra, is an associative algebra that extends the concept of complex numbers to higher dimensions while preserving the geometric interpretation of multiplication.","category":"page"},{"location":"mathematical_background/#Formal-Definition","page":"Mathematical Background","title":"Formal Definition","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Given a vector space V over the real numbers ℝ with a symmetric bilinear form Q (quadratic form), the Clifford algebra Cl(V,Q) is the quotient of the tensor algebra T(V) by the two-sided ideal I generated by elements of the form:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"v ⊗ v - Q(v,v) · 1","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"for all v ∈ V.","category":"page"},{"location":"mathematical_background/#Signature-Notation","page":"Mathematical Background","title":"Signature Notation","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"A Clifford algebra is often denoted by its signature (p,q,r) where:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"p = number of basis vectors that square to +1\nq = number of basis vectors that square to -1  \nr = number of basis vectors that square to 0","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The total dimension of the underlying vector space is n = p + q + r.","category":"page"},{"location":"mathematical_background/#The-Clifford-Relation","page":"Mathematical Background","title":"The Clifford Relation","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The fundamental relation in a Clifford algebra is:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"eᵢeⱼ + eⱼeᵢ = 2ηᵢⱼ","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"where ηᵢⱼ is the metric tensor. For orthonormal basis vectors:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"eᵢ² = +1 if i ≤ p (positive signature)\neᵢ² = -1 if p < i ≤ p+q (negative signature)\neᵢ² = 0 if i > p+q (null signature)","category":"page"},{"location":"mathematical_background/#Multivectors-and-Grades","page":"Mathematical Background","title":"Multivectors and Grades","text":"","category":"section"},{"location":"mathematical_background/#Grade-Structure","page":"Mathematical Background","title":"Grade Structure","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"A general element (multivector) in Cl(p,q,r) can be decomposed by grade:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"M = M₀ + M₁ + M₂ + ... + Mₙ","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"where Mₖ contains only k-vectors (elements of grade k).","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Grade 0: Scalars\nGrade 1: Vectors  \nGrade 2: Bivectors (oriented areas)\nGrade 3: Trivectors (oriented volumes)\nGrade n: Pseudoscalars","category":"page"},{"location":"mathematical_background/#Basis-Elements","page":"Mathematical Background","title":"Basis Elements","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"For an n-dimensional space, there are 2ⁿ basis elements:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"1 scalar: 1\n(n choose 1) vectors: eᵢ\n(n choose 2) bivectors: eᵢeⱼ (i < j)\n...\n1 pseudoscalar: e₁e₂...eₙ","category":"page"},{"location":"mathematical_background/#Example:-Cl(2,0,0)","page":"Mathematical Background","title":"Example: Cl(2,0,0)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"In 2D Euclidean space:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Basis: {1, e₁, e₂, e₁e₂}\nRelations: e₁² = e₂² = 1, e₁e₂ = -e₂e₁","category":"page"},{"location":"mathematical_background/#Products-in-Clifford-Algebra","page":"Mathematical Background","title":"Products in Clifford Algebra","text":"","category":"section"},{"location":"mathematical_background/#Geometric-Product","page":"Mathematical Background","title":"Geometric Product","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The geometric product is the fundamental operation, combining the inner and outer products:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"ab = a·b + a∧b","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Properties:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Associative: (ab)c = a(bc)\nDistributive: a(b+c) = ab + ac\nGenerally non-commutative","category":"page"},{"location":"mathematical_background/#Exterior-Product-(Wedge-Product)","page":"Mathematical Background","title":"Exterior Product (Wedge Product)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The exterior product a∧b creates higher-grade elements:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"a∧b = ½(ab - ba)","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Properties:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Anti-commutative: a∧b = -b∧a\nAssociative: (a∧b)∧c = a∧(b∧c)\na∧a = 0","category":"page"},{"location":"mathematical_background/#Interior-Product-(Contraction)","page":"Mathematical Background","title":"Interior Product (Contraction)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Several types of contraction exist:","category":"page"},{"location":"mathematical_background/#Left-Contraction-()","page":"Mathematical Background","title":"Left Contraction (⨼)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"a⨼b = Σₖ ⟨ab⟩ₖ₋ᵢ where a has grade i","category":"page"},{"location":"mathematical_background/#Right-Contraction-()","page":"Mathematical Background","title":"Right Contraction (⨽)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"a⨽b = Σₖ ⟨ab⟩ⱼ₋ₖ where b has grade j","category":"page"},{"location":"mathematical_background/#Fat-Dot-Product-()","page":"Mathematical Background","title":"Fat Dot Product (⋅)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"a⋅b = Σₖ ⟨ab⟩|ᵢ₋ⱼ| ","category":"page"},{"location":"mathematical_background/#Scalar-Product-()","page":"Mathematical Background","title":"Scalar Product (⋆)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"a⋆b = ⟨ab⟩₀ (grade 0 part only)","category":"page"},{"location":"mathematical_background/#Involutions-and-Operations","page":"Mathematical Background","title":"Involutions and Operations","text":"","category":"section"},{"location":"mathematical_background/#Grade-Involution","page":"Mathematical Background","title":"Grade Involution","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"α̃ = Σₖ (-1)ᵏ ⟨α⟩ₖ","category":"page"},{"location":"mathematical_background/#Reverse-(Reversion)","page":"Mathematical Background","title":"Reverse (Reversion)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"α† = Σₖ (-1)^(k(k-1)/2) ⟨α⟩ₖ","category":"page"},{"location":"mathematical_background/#Clifford-Conjugation","page":"Mathematical Background","title":"Clifford Conjugation","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"α̅ = Σₖ (-1)^(k(k+1)/2) ⟨α⟩ₖ","category":"page"},{"location":"mathematical_background/#Duality","page":"Mathematical Background","title":"Duality","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The Hodge dual with respect to the pseudoscalar I:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"*α = αI⁻¹","category":"page"},{"location":"mathematical_background/#Exponential-and-Logarithm","page":"Mathematical Background","title":"Exponential and Logarithm","text":"","category":"section"},{"location":"mathematical_background/#Exponential-of-Bivectors","page":"Mathematical Background","title":"Exponential of Bivectors","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"For a bivector B, the exponential gives:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"e^B = cos(|B|) + (B/|B|)sin(|B|)","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"This formula generates rotations (for positive signature) or hyperbolic rotations (for mixed signature).","category":"page"},{"location":"mathematical_background/#Rotor-Representation","page":"Mathematical Background","title":"Rotor Representation","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"A rotor R = e^(B/2) represents a rotation by angle |B| in the plane defined by B. The rotation is applied via:","category":"page"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"v' = RvR†","category":"page"},{"location":"mathematical_background/#Common-Clifford-Algebras","page":"Mathematical Background","title":"Common Clifford Algebras","text":"","category":"section"},{"location":"mathematical_background/#Cl(2,0,0)-2D-Euclidean","page":"Mathematical Background","title":"Cl(2,0,0) - 2D Euclidean","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Used for 2D rotations and complex numbers\nIsomorphic to ℝ + ℝ² (scalar + vector)","category":"page"},{"location":"mathematical_background/#Cl(3,0,0)-3D-Euclidean","page":"Mathematical Background","title":"Cl(3,0,0) - 3D Euclidean","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Standard 3D vector algebra with cross product\nQuaternions live in the even subalgebra","category":"page"},{"location":"mathematical_background/#Cl(1,3,0)-Spacetime-Algebra","page":"Mathematical Background","title":"Cl(1,3,0) - Spacetime Algebra","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Used in relativistic physics\nSignature matches Minkowski spacetime","category":"page"},{"location":"mathematical_background/#Cl(3,0,1)-Projective-Geometric-Algebra-(PGA)","page":"Mathematical Background","title":"Cl(3,0,1) - Projective Geometric Algebra (PGA)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Ideal for computer graphics and robotics\nIncludes points at infinity naturally","category":"page"},{"location":"mathematical_background/#Cl(4,1,0)-Conformal-Geometric-Algebra-(CGA)","page":"Mathematical Background","title":"Cl(4,1,0) - Conformal Geometric Algebra (CGA)","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Unified treatment of Euclidean geometry\nCircles, spheres, and transformations","category":"page"},{"location":"mathematical_background/#Implementation-Notes","page":"Mathematical Background","title":"Implementation Notes","text":"","category":"section"},{"location":"mathematical_background/#Sparse-Representation","page":"Mathematical Background","title":"Sparse Representation","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"CliffordAlgebras.jl uses sparse representation, storing only non-zero coefficients. This is crucial for efficiency in high-dimensional algebras where most coefficients are typically zero.","category":"page"},{"location":"mathematical_background/#Generated-Functions","page":"Mathematical Background","title":"Generated Functions","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"The package uses @generated functions to create specialized code for each algebra type at compile time, ensuring optimal performance.","category":"page"},{"location":"mathematical_background/#Type-Stability","page":"Mathematical Background","title":"Type Stability","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Most operations maintain type stability, meaning the return type can be inferred at compile time, leading to efficient machine code generation.","category":"page"},{"location":"mathematical_background/#References","page":"Mathematical Background","title":"References","text":"","category":"section"},{"location":"mathematical_background/","page":"Mathematical Background","title":"Mathematical Background","text":"Doran, C. & Lasenby, A. (2003). Geometric Algebra for Physicists. Cambridge University Press.\nDorst, L., Fontijne, D., & Mann, S. (2007). Geometric Algebra for Computer Science. Morgan Kaufmann.\nHestenes, D. & Sobczyk, G. (1984). Clifford Algebra to Geometric Calculus. D. Reidel Publishing Company.\nPerwass, C. (2009). Geometric Algebra with Applications in Engineering. Springer.","category":"page"},{"location":"performance/#Performance-Guide","page":"Performance Guide","title":"Performance Guide","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"This guide provides tips and best practices for achieving optimal performance with CliffordAlgebras.jl.","category":"page"},{"location":"performance/#Quick-performance-checklist","page":"Performance Guide","title":"Quick performance checklist","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Prefer sparse operations; avoid unnecessary extend() in hot paths.\nKeep operands in the same algebra type; avoid converting between algebras.\nReuse compiled structures: precompute rotors and reuse them.\nAim for type stability; use @inferred in performance-critical code.\nAvoid excessive prune() calls; use it judiciously after larger expressions.\nChoose the smallest algebra sufficient for the task (e.g., Cl(2) for 2D rotations).\nProfile before optimizing; measure allocations and timing.","category":"page"},{"location":"performance/#Understanding-the-Design","page":"Performance Guide","title":"Understanding the Design","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"CliffordAlgebras.jl is designed for high performance through several key features:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Sparse Representation: Only non-zero coefficients are stored\nGenerated Functions: Compile-time specialization for each algebra\nType Stability: Most operations have inferrable return types\nZero-Cost Abstractions: Overhead is eliminated at compile time","category":"page"},{"location":"performance/#Type-Stability","page":"Performance Guide","title":"Type Stability","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Type stability is crucial for Julia performance. Most CliffordAlgebras.jl operations are type-stable:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using CliffordAlgebras\n\ncl3 = CliffordAlgebra(3)\nmv1 = cl3.e1 + cl3.e2\nmv2 = cl3.e2 + cl3.e3\n\n# These operations are type-stable\n@inferred mv1 * mv2          # Geometric product\n@inferred mv1 ∧ mv2          # Exterior product  \n@inferred ~mv1               # Reverse\n@inferred exp(cl3.e1e2)      # Exponential","category":"page"},{"location":"performance/#Non-Type-Stable-Operations","page":"Performance Guide","title":"Non-Type-Stable Operations","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Some operations are intentionally not type-stable for flexibility:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# prune() changes the sparse structure\npruned = prune(mv1)  # Return type depends on which coefficients survive\n\n# Use extend() for type stability if needed\nextended = extend(mv1)  # Always returns full representation","category":"page"},{"location":"performance/#Memory-Efficiency","page":"Performance Guide","title":"Memory Efficiency","text":"","category":"section"},{"location":"performance/#Sparse-vs-Dense-Representation","page":"Performance Guide","title":"Sparse vs Dense Representation","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"CliffordAlgebras.jl automatically uses sparse representation:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"cl8 = CliffordAlgebra(8)  # 2^8 = 256 basis elements\n\n# This only stores 2 coefficients, not 256\nsparse_mv = cl8.e1 + cl8.e8\n\n# Convert to dense if needed (usually not recommended)\ndense_mv = extend(sparse_mv)","category":"page"},{"location":"performance/#Memory-Usage-Guidelines","page":"Performance Guide","title":"Memory Usage Guidelines","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Prefer sparse operations: Most functions preserve sparsity\nAvoid unnecessary extend(): Only use when type stability is critical\nReuse multivectors: Modify in-place when possible","category":"page"},{"location":"performance/#Compile-Time-Optimization","page":"Performance Guide","title":"Compile-Time Optimization","text":"","category":"section"},{"location":"performance/#Generated-Functions","page":"Performance Guide","title":"Generated Functions","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"The package uses @generated functions for optimal performance:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# This generates specialized code for each algebra and multivector type\nfunction (*)(a::MultiVector{CA}, b::MultiVector{CA}) where CA\n    # Specialized implementation generated at compile time\nend","category":"page"},{"location":"performance/#Specialization-Tips","page":"Performance Guide","title":"Specialization Tips","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Use concrete types: Avoid MultiVector without type parameters\nConsistent algebra types: Don't mix algebras in hot loops\nStable multivector structures: Reuse similar sparse patterns","category":"page"},{"location":"performance/#Benchmarking-Examples","page":"Performance Guide","title":"Benchmarking Examples","text":"","category":"section"},{"location":"performance/#Basic-Operations","page":"Performance Guide","title":"Basic Operations","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using BenchmarkTools, CliffordAlgebras\n\ncl3 = CliffordAlgebra(3)\nmv1 = 1.0 + cl3.e1 + cl3.e2 + cl3.e1e2\nmv2 = 2.0 + cl3.e2 + cl3.e3 + cl3.e2e3\n\n# Benchmark geometric product\n@benchmark $mv1 * $mv2\n\n# Benchmark exterior product  \n@benchmark $mv1 ∧ $mv2\n\n# Benchmark exponential\nB = π/4 * cl3.e1e2\n@benchmark exp($B)","category":"page"},{"location":"performance/#Large-Algebras","page":"Performance Guide","title":"Large Algebras","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# For larger algebras, sparsity becomes crucial\ncl6 = CliffordAlgebra(6)  # 64 basis elements\n\n# Sparse multivector (only 3 coefficients)\nsparse_mv = cl6.e1 + cl6.e3 + cl6.e6\n\n# Still efficient due to sparsity\n@benchmark $sparse_mv * $sparse_mv","category":"page"},{"location":"performance/#Optimization-Strategies","page":"Performance Guide","title":"Optimization Strategies","text":"","category":"section"},{"location":"performance/#1.-Precompute-Common-Operations","page":"Performance Guide","title":"1. Precompute Common Operations","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Instead of recomputing rotors\nangle = π/6\nB = angle * cl3.e1e2\nrotor = exp(B)  # Precompute this\n\n# Use the precomputed rotor many times\nfor vector in vectors\n    rotated = rotor ≀ vector\nend","category":"page"},{"location":"performance/#2.-Use-Appropriate-Signatures","page":"Performance Guide","title":"2. Use Appropriate Signatures","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Choose the minimal signature for your problem:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# For 2D rotations, Cl(2,0,0) is more efficient than Cl(3,0,0)\ncl2 = CliffordAlgebra(2)  # 4 basis elements vs 8\n\n# For spacetime, use the exact signature\nsta = CliffordAlgebra(1, 3, 0)  # Not Cl(4,0,0)","category":"page"},{"location":"performance/#3.-Minimize-Allocations","page":"Performance Guide","title":"3. Minimize Allocations","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Good: Reuse multivectors when possible\nfunction rotate_many_vectors!(results, rotor, vectors)\n    for (i, v) in enumerate(vectors)\n        results[i] = rotor ≀ v\n    end\nend\n\n# Avoid: Creating new algebras in hot loops\nfunction bad_example()\n    for i in 1:1000\n        cl = CliffordAlgebra(3)  # Don't do this!\n        # ... operations\n    end\nend","category":"page"},{"location":"performance/#4.-Leverage-Type-Annotations","page":"Performance Guide","title":"4. Leverage Type Annotations","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Help the compiler with type annotations\nfunction efficient_computation(mv::MultiVector{CA,Float64}) where CA\n    result = mv * mv\n    return scalar(result)\nend","category":"page"},{"location":"performance/#Performance-Pitfalls","page":"Performance Guide","title":"Performance Pitfalls","text":"","category":"section"},{"location":"performance/#1.-Type-Instability","page":"Performance Guide","title":"1. Type Instability","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Bad: Type-unstable function\nfunction unstable_norm(mv)\n    if some_condition\n        return norm(mv)  # Returns Float64\n    else\n        return mv        # Returns MultiVector\n    end\nend\n\n# Good: Type-stable alternatives\nfunction stable_norm(mv)\n    return norm(mv)  # Always returns Float64\nend","category":"page"},{"location":"performance/#2.-Unnecessary-Conversions","page":"Performance Guide","title":"2. Unnecessary Conversions","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Bad: Converting between algebras\ncl2_mv = cl2.e1\ncl3_mv = MultiVector(cl3, (1.0, 0.0, 0.0))  # Expensive conversion\n\n# Good: Work within one algebra\nmv1 = cl3.e1\nmv2 = cl3.e2\nresult = mv1 * mv2","category":"page"},{"location":"performance/#3.-Overuse-of-prune()","page":"Performance Guide","title":"3. Overuse of prune()","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"# Bad: Excessive pruning\nresult = mv1 * mv2\nresult = prune(result)  # Type-unstable and often unnecessary\nresult = result + mv3\nresult = prune(result)  # Again!\n\n# Good: Prune only when needed\nresult = mv1 * mv2 + mv3\n# Only prune if you know there are many small coefficients\nif need_cleanup\n    result = prune(result)\nend","category":"page"},{"location":"performance/#Profiling-Tools","page":"Performance Guide","title":"Profiling Tools","text":"","category":"section"},{"location":"performance/#Memory-Allocation","page":"Performance Guide","title":"Memory Allocation","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using Profile\n\nfunction profile_example()\n    cl4 = CliffordAlgebra(4)\n    mv = cl4.e1 + cl4.e2 + cl4.e3 + cl4.e4\n    \n    for i in 1:1000\n        result = mv * mv\n    end\nend\n\n# Profile memory allocations\n@profile profile_example()\nProfile.print()","category":"page"},{"location":"performance/#Type-Inference","page":"Performance Guide","title":"Type Inference","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"using Cthulhu\n\n# Inspect generated code\ncl3 = CliffordAlgebra(3)\nmv1 = cl3.e1\nmv2 = cl3.e2\n\n# Descend into the multiplication\n@descend mv1 * mv2","category":"page"},{"location":"performance/#Performance-Summary","page":"Performance Guide","title":"Performance Summary","text":"","category":"section"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Fast Operations:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Geometric product between similar multivectors\nExponential of bivectors  \nGrade extraction\nReverse and other involutions","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Moderate Operations:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Operations between very different sparse structures\nConverting between representations\nComplex expressions with many terms","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Slow Operations:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Excessive use of prune()\nMixing different algebras\nType-unstable code patterns","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Best Practices:","category":"page"},{"location":"performance/","page":"Performance Guide","title":"Performance Guide","text":"Stick to one algebra type per computation\nLeverage sparsity naturally\nPrecompute rotors and other expensive operations\nUse @inferred to check type stability\nProfile before optimizing\nChoose minimal sufficient algebra signatures","category":"page"},{"location":"developer/#Developer-Guide","page":"Developer Guide","title":"Developer Guide","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Welcome! This page is a quick pointer for contributors.","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"See CONTRIBUTING.md at the repo root for setup, coding style, and PR tips.\nSee CHANGELOG.md for a summary of notable changes.","category":"page"},{"location":"developer/#Running-the-tests","page":"Developer Guide","title":"Running the tests","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Unit tests live in test/runtests.jl.\nDoctests are enabled and run as part of the docs build.\nAqua.jl quality checks run from test/aqua.jl and are included in runtests.jl.","category":"page"},{"location":"developer/#Useful-commands","page":"Developer Guide","title":"Useful commands","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Run the package tests locally (uses your default Julia):","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"using Pkg\nPkg.activate(temp=true)\nPkg.develop(path=\"/absolute/path/to/CliffordAlgebras.jl\")\nPkg.test(\"CliffordAlgebras\")","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Build the docs locally:","category":"page"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"using Pkg\nPkg.activate(\"docs\")\nPkg.instantiate()\ninclude(\"docs/make.jl\")","category":"page"},{"location":"developer/#Notes-on-precompilation","page":"Developer Guide","title":"Notes on precompilation","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"We include a small PrecompileTools workload in src/precompile.jl to reduce first-call latency without slowing precompilation. Keep it lightweight; avoid calling heavy or world-age-sensitive paths.","category":"page"},{"location":"developer/#Reporting-issues","page":"Developer Guide","title":"Reporting issues","text":"","category":"section"},{"location":"developer/","page":"Developer Guide","title":"Developer Guide","text":"Please open an issue with a minimal reproducer and version info (Julia version, OS, package version). Thanks for contributing!","category":"page"},{"location":"#CliffordAlgebras.jl-Documentation","page":"Home","title":"CliffordAlgebras.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fast, lightweight and easy-to-use Julia package for Clifford Algebras and Geometric Algebras.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CliffordAlgebras.jl provides a comprehensive implementation of Clifford algebras (also known as geometric algebras) in Julia. The package uses compile-time code generation, sparse multivector representation, and special case identification to handle arbitrary geometric algebras efficiently.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install and load the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/ATell-SoundTheory/CliffordAlgebras.jl\")\nusing CliffordAlgebras","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using CliffordAlgebras\n\njulia> cl2 = CliffordAlgebra(2)\nCl(2,0,0)\n\njulia> e1, e2, e12 = cl2.e1, cl2.e2, cl2.e1e2;\n\njulia> mv = 1 + 2*e1 + 3*e2 + 4*e12;\n\njulia> mv * e1 isa MultiVector\ntrue\n\njulia> e1 ∧ e2 == cl2.e1e2\ntrue","category":"page"},{"location":"#Mathematical-Background","page":"Home","title":"Mathematical Background","text":"","category":"section"},{"location":"#Clifford-Algebras","page":"Home","title":"Clifford Algebras","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Clifford algebra Cl(p,q,r) is an associative algebra over the real numbers with a signature (p,q,r), where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = number of basis vectors that square to +1\nq = number of basis vectors that square to -1  \nr = number of basis vectors that square to 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The fundamental relation is the Clifford relation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"eᵢeⱼ + eⱼeᵢ = 2ηᵢⱼ","category":"page"},{"location":"","page":"Home","title":"Home","text":"where ηᵢⱼ is the metric tensor.","category":"page"},{"location":"#Multivectors","page":"Home","title":"Multivectors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A general multivector in Cl(p,q,r) can be written as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"M = α + aᵢeᵢ + aᵢⱼeᵢeⱼ + ... + a₁₂...ₙe₁e₂...eₙ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package represents multivectors using a sparse representation, storing only non-zero coefficients.","category":"page"},{"location":"#Creating-Algebras","page":"Home","title":"Creating Algebras","text":"","category":"section"},{"location":"#Basic-Signatures","page":"Home","title":"Basic Signatures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Euclidean algebras\ncl2 = CliffordAlgebra(2)        # Cl(2,0,0)\ncl3 = CliffordAlgebra(3)        # Cl(3,0,0)\n\n# Mixed signatures\nspa = CliffordAlgebra(1,3)      # Cl(1,3,0) - Spacetime algebra\npga = CliffordAlgebra(3,0,1)    # Cl(3,0,1) - Projective geometric algebra\n\n# Full signature specification\ncustom = CliffordAlgebra(2,1,1) # Cl(2,1,1)","category":"page"},{"location":"#Predefined-Algebras","page":"Home","title":"Predefined Algebras","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package includes many commonly used algebras:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Complex numbers\nℂ = CliffordAlgebra(:Complex)\n\n# Quaternions  \nℍ = CliffordAlgebra(:Quaternions)\n\n# Spacetime algebra\nsta = CliffordAlgebra(:Spacetime)\n\n# Projective geometric algebras\npga2d = CliffordAlgebra(:PGA2D)\npga3d = CliffordAlgebra(:PGA3D)\n\n# Conformal geometric algebras\ncga2d = CliffordAlgebra(:CGA2D)\ncga3d = CliffordAlgebra(:CGA3D)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tip: See “Typing Unicode operators” in the README for how to enter symbols like ∧, ⋅, ⨼, and ≀ in the REPL and editors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also: the \"Algebra Catalog\" page for a table of predefined algebras, signatures, and base symbols, the new \"Recipes\" page for practical CGA/PGA snippets, and the \"Cheat Sheet\" for quick operator mappings and patterns.","category":"page"},{"location":"#Working-with-Multivectors","page":"Home","title":"Working with Multivectors","text":"","category":"section"},{"location":"#Creating-Multivectors","page":"Home","title":"Creating Multivectors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"cl3 = CliffordAlgebra(3)\n\n# From scalar\nscalar_mv = MultiVector(cl3, 5.0)\n\n# From basis vectors\nmv1 = cl3.e1 + 2*cl3.e2 + 3*cl3.e1e2\n\n# From vector components\nvector_mv = MultiVector(cl3, (1.0, 2.0, 3.0))","category":"page"},{"location":"#Operations","page":"Home","title":"Operations","text":"","category":"section"},{"location":"#Geometric-Product-(*)","page":"Home","title":"Geometric Product (*)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The fundamental operation in Clifford algebra:","category":"page"},{"location":"","page":"Home","title":"Home","text":"result = mv1 * mv2","category":"page"},{"location":"#Exterior-Product-()","page":"Home","title":"Exterior Product (∧)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Anti-commutative product that creates higher-grade elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"bivector = cl3.e1 ∧ cl3.e2  # Creates e1e2","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you prefer ASCII, you can use function names instead of Unicode operators, e.g. exteriorprod(mv1, mv2) for mv1 ∧ mv2.","category":"page"},{"location":"#Interior-Products","page":"Home","title":"Interior Products","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Various contraction operations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"left_contraction = mv1 ⨼ mv2   # Left contraction\nright_contraction = mv1 ⨽ mv2  # Right contraction\nfat_dot = mv1 ⋅ mv2            # Fat dot product\nscalar_product = mv1 ⋆ mv2     # Scalar product","category":"page"},{"location":"#Involutions","page":"Home","title":"Involutions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"reverse_mv = ~mv1              # Reverse (grade involution)\nconjugate_mv = conj(mv1)       # Clifford conjugation\ngrade_inv = grin(mv1)          # Grade involution\ndual_mv = dual(mv1)            # Hodge dual","category":"page"},{"location":"#Grade-Operations","page":"Home","title":"Grade Operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Extract specific grades\nscalar_part = scalar(mv)\ngrade_2 = grade(mv, 2)\neven_part = even(mv)\nodd_part = odd(mv)\n\n# Grade queries\nis_vector = isgrade(mv, 1)\nmax_grade_mv, max_g = maxgrade(mv)","category":"page"},{"location":"#Advanced-Features","page":"Home","title":"Advanced Features","text":"","category":"section"},{"location":"#Exponential-and-Trigonometric-Functions","page":"Home","title":"Exponential and Trigonometric Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Exponential of bivector (rotation)\nB = π/4 * cl3.e1e2\nrotor = exp(B)\n\n# Apply rotation using sandwich product\nrotated_vector = rotor ≀ cl3.e3","category":"page"},{"location":"#Matrix-Representation","page":"Home","title":"Matrix Representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Convert to matrix form\nmatrix_form = matrix(mv)\nvector_form = vector(mv)\n\n# Matrix multiplication is equivalent to geometric product\n@assert matrix(mv1) * matrix(mv2) == matrix(mv1 * mv2)","category":"page"},{"location":"#Outermorphisms","page":"Home","title":"Outermorphisms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Apply linear transformations to the underlying vector space:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# 2x2 rotation matrix\nθ = π/4\nR = [cos(θ) -sin(θ); sin(θ) cos(θ)]\n\n# Apply to multivector\ntransformed_mv = outermorphism(R, mv)","category":"page"},{"location":"#Performance-Considerations","page":"Home","title":"Performance Considerations","text":"","category":"section"},{"location":"#Sparse-Representation","page":"Home","title":"Sparse Representation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package automatically uses sparse representation for efficiency:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Only stores non-zero coefficients\nsparse_mv = cl3.e1 + cl3.e1e2e3  # Only 2 coefficients stored","category":"page"},{"location":"#Type-Stability","page":"Home","title":"Type Stability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most operations are type-stable for optimal performance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# These operations are typically type-stable\n@inferred mv1 * mv2\n@inferred exp(bivector)\n@inferred ~mv1","category":"page"},{"location":"#Generated-Functions","page":"Home","title":"Generated Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package uses @generated functions for compile-time optimization, ensuring efficient code for each algebra and multivector type.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#2D-Rotations","page":"Home","title":"2D Rotations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"cl2 = CliffordAlgebra(2)\n\n# Create a vector\nv = cl2.e1\n\n# Create rotation bivector (π/4 rotation)\nB = π/4 * cl2.e1e2\n\n# Create rotor\nR = exp(B)\n\n# Apply rotation\nrotated_v = R ≀ v","category":"page"},{"location":"#3D-Spacetime","page":"Home","title":"3D Spacetime","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"sta = CliffordAlgebra(:Spacetime)  # Cl(1,3,0)\n\n# Create spacetime vector\nevent = sta.t + 2*sta.x + 3*sta.y + 4*sta.z\n\n# Compute spacetime interval\ninterval = scalar(event * ~event)","category":"page"},{"location":"algebras/#Algebra-Catalog","page":"Algebra Catalog","title":"Algebra Catalog","text":"","category":"section"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"This page lists predefined algebra aliases available in CliffordAlgebras.jl, along with their signatures and quick facts.","category":"page"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"Alias(es) Signature (p,q,r) Base symbols Notes\n:Cl2 (2,0,0) (:e1, :e2) 2D Euclidean; complex-plane-like bivector e1e2\n:Cl3 (3,0,0) (:e1, :e2, :e3) 3D Euclidean; rotors from bivectors\n:Spacetime, :STA (1,3,0) (:t, :x, :y, :z) Minkowski spacetime\n:Complex, :ℂ (0,1,0) (:i,) Complex numbers as a 2D algebra\n:Quaternions, :ℍ (0,2,0) (:i, :j) Even subalgebra of Cl(3,0,0) isomorphic to quaternions\n:Hyperbolic, :Hyper (1,0,0) (:j,) Hyperbolic numbers\n:Dual, :Grassmann (0,0,1) (:ε,) Dual numbers (nilpotent)\n:Grassmann2D, :G2 (0,0,2) (:ε₁, :ε₂) 2D Grassmann (both square to 0)\n:Grassmann3D, :G3 (0,0,3) (:ε₁, :ε₂, :ε₃) 3D Grassmann\n:PGA2D, :Projective2D, :Plane2D (2,0,1) (:e1, :e2, :e0) Projective GA (2D); e0^2=0\n:PGA3D, :Projective3D, :Plane3D (3,0,1) (:e1, :e2, :e3, :e0) Projective GA (3D); e0 is null\n:CGA2D, :Conformal2D (3,1,0) (:e1, :e2, :e₊, :e₋) Conformal GA (2D)\n:CGA3D, :Conformal3D (4,1,0) (:e1, :e2, :e3, :e₊, :e₋) Conformal GA (3D)\n:DCGA3D, :DoubleConformal3D (6,2,0) — Double conformal (3D)\n:TCGA3D, :TripleConformal3D (9,3,0) — Triple conformal (3D)\n:DCGSTA, :DoubleConformalSpacetime (4,8,0) (:t₁, :t₂, :e₊₁, :e₊₂, :x₁, :x₂, :y₁, :y₂, :z₁, :z₂, :e₋₁, :e₋₂) DCG for spacetime\n:QCGA, :QuadricConformal (9,6,0) — Quadric conformal","category":"page"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"Tip: Use signaturetable(stdout, algebra) to view per-basis signatures and cayleytable(stdout, algebra) for the full multiplication table. If the PrettyTables package is available in your environment, these functions render via a package extension; otherwise, a Unicode fallback renderer is used.","category":"page"},{"location":"algebras/#Quick-facts-and-size","page":"Algebra Catalog","title":"Quick facts and size","text":"","category":"section"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"For an algebra with signature (p,q,r) and order n = p+q+r:","category":"page"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"Dimension of the full algebra: 2^n elements.\nNumber of k-vectors (grade k): C(n,k).\nPseudoscalar I has grade n and I^2 = character(algebra) ∈ {+1,-1,0}.\nNull basis elements (r > 0) square to 0 and model points at infinity or conformal components.","category":"page"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"Examples:","category":"page"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"Cl(3): n=3, dim=8, grades per k: 1, 3, 3, 1.\nPGA3D (3,0,1): n=4, dim=16, with one null basis e0.\nCGA3D (4,1,0): n=5, dim=32, two lightlike directions from e₊, e₋.","category":"page"},{"location":"algebras/#Typical-use-cases","page":"Algebra Catalog","title":"Typical use cases","text":"","category":"section"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"Cl(2), Cl(3): Euclidean plane/space; basic rotations, rigid body kinematics (rotors from bivectors).\nSTA (Cl(1,3,0)): Relativistic spacetime computations.\nPGA2D/PGA3D: Projective geometry for graphics/robotics; lines/planes at infinity via null basis e0.\nCGA2D/CGA3D: Conformal geometry for points, circles/spheres, and conformal transforms.\nℂ / ℍ: Complex/quaternion arithmetic embedded in geometric algebra contexts.","category":"page"},{"location":"algebras/#Examples","page":"Algebra Catalog","title":"Examples","text":"","category":"section"},{"location":"algebras/","page":"Algebra Catalog","title":"Algebra Catalog","text":"julia> using CliffordAlgebras\n\njulia> pga = CliffordAlgebra(:PGA3D);\n\njulia> io = IOBuffer(); signaturetable(io, pga); true\ntrue\n\njulia> e0 = basevector(pga, :e0);  # null basis vector\n\njulia> scalar(e0*e0)\n0\n\njulia> cga = CliffordAlgebra(:CGA3D);\n\njulia> eplus = basevector(cga, :e₊); eminus = basevector(cga, :e₋);\n\njulia> (scalar(eplus*eplus), scalar(eminus*eminus))\n(1, -1)","category":"page"},{"location":"faq/#FAQ-and-Tips","page":"FAQ & Tips","title":"FAQ & Tips","text":"","category":"section"},{"location":"faq/#How-do-I-install-the-package?","page":"FAQ & Tips","title":"How do I install the package?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"This package is currently hosted on GitHub. Install with:","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"import Pkg\nPkg.add(url=\"https://github.com/ATell-SoundTheory/CliffordAlgebras.jl\")","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"For local development:","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"import Pkg\nPkg.develop(path=\"/absolute/path/to/CliffordAlgebras.jl\")","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Minimum Julia version: 1.6.","category":"page"},{"location":"faq/#How-do-I-type-Unicode-operators-like-?","page":"FAQ & Tips","title":"How do I type Unicode operators like ∧ ⋅ ⨼ ⨽ ×₋ ≀ ?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Use Julia's LaTeX-style tab completions in the REPL and many editors:","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"\\wedge<Tab> → ∧ (exterior)\n\\vee<Tab> → ∨ (regressive)\n\\cdot<Tab> → ⋅ (fat dot)\n\\lrcorner<Tab> → ⨼ (left contraction)\n\\llcorner<Tab> → ⨽ (right contraction)\n\\star<Tab> → ⋆ (scalar)\n\\times<Tab>\\_ -<Tab> → ×₋ (commutator)\n\\times<Tab>\\_ +<Tab> → ×₊ (anti-commutator)\n\\Vert<Tab> → ≀ (sandwich)","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"ASCII alternatives (function calls):","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"exteriorprod(a,b) for a ∧ b\nfatdotprod(a,b) for a ⋅ b\nleftcontractionprod(a,b) for a ⨼ b\nrightcontractionprod(a,b) for a ⨽ b\nscalarprod(a,b) for a ⋆ b\ncommutatorprod(a,b) for a ×₋ b\nanticommutatorprod(a,b) for a ×₊ b\nsandwichproduct(a,b) for a ≀ b","category":"page"},{"location":"faq/#What-predefined-algebras-are-available?","page":"FAQ & Tips","title":"What predefined algebras are available?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Common aliases include:","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":":Complex (ℂ), :Quaternions (ℍ)\n:Spacetime (STA)\n:PGA2D, :PGA3D\n:CGA2D, :CGA3D","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"See the examples on the Home page for usage.","category":"page"},{"location":"faq/#How-do-I-benchmark-operations?","page":"FAQ & Tips","title":"How do I benchmark operations?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"This repository includes a small benchmark suite under benchmark/.","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Quick run:","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"julia --project=benchmark benchmark/run.jl","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Full PkgBenchmark run:","category":"page"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"julia --project=benchmark -e 'using PkgBenchmark, CliffordAlgebras; benchmarkpkg(CliffordAlgebras)'","category":"page"},{"location":"faq/#Can-I-use-ASCII-only-code?","page":"FAQ & Tips","title":"Can I use ASCII-only code?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Yes. All Unicode operators have function equivalents (see above). You can also import and call CliffordAlgebras.<name> functions directly.","category":"page"},{"location":"faq/#I-get-a-MethodError-mixing-different-algebras","page":"FAQ & Tips","title":"I get a MethodError mixing different algebras","text":"","category":"section"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Operations require both operands to belong to the same algebra. Construct both operands from the same CliffordAlgebra(...) instance.","category":"page"},{"location":"faq/#prune-changes-the-type-—-is-that-intended?","page":"FAQ & Tips","title":"prune changes the type — is that intended?","text":"","category":"section"},{"location":"faq/","page":"FAQ & Tips","title":"FAQ & Tips","text":"Yes. prune removes zero coefficients and may return a different sparse type. Use extend(mv) if you need a full, fixed representation.","category":"page"}]
}
